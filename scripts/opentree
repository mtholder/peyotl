#!/usr/bin/env python
from peyotl import logger, get_config_setting, get_config_object, report_on_env
from peyotl.jobs import ALL_SERVICE_NAMES
from peyotl.otservices import (launch_services,
                               service_status, stop_services,
                               write_service_log_tail,
                               )

# from peyotl.ott import OTT
# import subprocess
import sys
import os

out = sys.stdout

def tail_command(args):
    a = args.services if isinstance(args.services, list) else [args.services]
    for service in a:
        write_service_log_tail(out, service, n=args.n)

def config_command(args):
    a = args.action if isinstance(args.action, list) else [args.action]
    for action in a:
        if action.lower() == 'list':
            report_on_env(out, verbose=args.verbose)
            cw = get_config_object()
            cw.report(out)

def start_command(args):
    launch_services(args.services)

def stop_command(args):
    stop_services(args.services)

def status_command(args):
    service_status([])

def ott_list_command(args):
    ott_dir = get_config_setting(['ott', 'directory'])
    if ott_dir is None:
        sys.exit('Did not find info about a local version of OTT. Configure the '
                 '[ott] section and "directory" setting of your config file to point '
                 'to the directory that holds an unpacked version of OTT.\n')
    out.write('Using OTT in "{}"\n'.format(ott_dir))


    #
    # def ott_clear_command(args):
    #    ott = OTT()
    #    ott.remove_caches()
    # def ott_shell_command(args):
    #    ott = OTT()
    #    logger(__name__).info('launching bash in your OTT dir...')
    #    if subprocess.Popen('bash', cwd=ott.ott_dir).wait() != 0:
    #        raise RuntimeError('bash in ott dir failed.')

def completions(partial, choices):
    r = []
    for c in choices:
        if partial == c:
            return []
        if c.startswith(partial):
            r.append(c)
    return r

def main():
    import argparse
    import readline

    parser = argparse.ArgumentParser(prog='opentree')
    parser.add_argument("--show-completions",
                        action="store_true",
                        default=False,
                        help="print the list of options for the next word in the command line")
    parser.add_argument("--verbose",
                        action="store_true",
                        default=False,
                        help="prints optional information for some commands")

    subparsers = parser.add_subparsers(help='available commands')
    # univ is the set of options that can affect every command
    univ = frozenset([])
    non_service_cmds = ('config', 'ott')
    service_cmds = ('start', 'status', 'stop', 'tail')
    all_cmds = non_service_cmds + service_cmds
    ################################################################################################
    #  config commands
    config_parser = subparsers.add_parser('config',
                                          help='reports information about your peyotl configuration')
    config_parser.add_argument('action', nargs='*', choices=['list'], default='list')
    config_parser.set_defaults(func=config_command)
    config_actions = ('list',)
    ################################################################################################
    #  ott commands
    ott_parser = subparsers.add_parser('ott', help='commands that require a local version of ott')
    ott_parser.add_argument('--action', choices=['list'], default='', required=False)
    ott_subparsers = ott_parser.add_subparsers(help='ott actions')
    ott_list_parser = ott_subparsers.add_parser('list', help='reports on the local version of OTT')
    ott_list_parser.set_defaults(func=ott_list_command)
    ott_actions = ('list',)
    # ott_clear_parser = ott_subparsers.add_parser('clear-cache',
    #                                             help='remove the caches used to speed up actions on OTT')
    # @TODO: Restore?
    #  ott_clear_parser.set_defaults(func=ott_clear_command)
    # ott_shell_parser = ott_subparsers.add_parser('bash',
    #                                            help='execute bash command in the top dir of your copy of OTT')
    # ott_shell_parser.set_defaults(func=ott_shell_command)
    ################################################################################################
    # Start service command
    start_parser = subparsers.add_parser('start',
                                          help='launches one of the Open Tree services locally')
    start_parser.add_argument('services', nargs='+', choices=ALL_SERVICE_NAMES, default=None)
    start_parser.set_defaults(func=start_command)
    ################################################################################################
    # Status
    status_parser = subparsers.add_parser('status',
                                         help='reports the status of open tree service/artifacts '
                                              'installation.')
    status_parser.add_argument('services', nargs='*', choices=ALL_SERVICE_NAMES, default='all')
    status_parser.set_defaults(func=status_command)
    ################################################################################################
    # Start service command
    stop_parser = subparsers.add_parser('stop',
                                         help='stops one of the Open Tree services running locally')
    stop_parser.add_argument('services', nargs='+', choices=ALL_SERVICE_NAMES, default=None)
    stop_parser.set_defaults(func=stop_command)
    ################################################################################################
    # tail service log command
    tail_parser = subparsers.add_parser('tail', help='writes the last n lines of the log of a service to stdout')
    tail_parser.add_argument('services', nargs='+', choices=ALL_SERVICE_NAMES, default=None)
    tail_parser.add_argument('-n', type=int, default=10)
    tail_parser.set_defaults(func=tail_command)

    ################################################################################################
    if "--show-completions" in sys.argv:
        args = sys.argv[1:]
        #sys.stderr.write('\na = {!r}\n'.format(a))
        last_word = args[-1] if args else ''
        sel_cmd = None
        num_cmds = 0
        for c in all_cmds:
            if c in args:
                if sel_cmd is None:
                    sel_cmd = c
                num_cmds += 1
        comp_list = []
        if sel_cmd is None:
            comp_list = []
            for u in univ:
                found = False
                for arg in args:
                    if arg.startswith(u):
                        found = True
                        break
                if not found:
                    comp_list.append(u)
            comp_list.extend(all_cmds)
        else:
            if sel_cmd in service_cmds:
                comp_list.extend([i for i in ALL_SERVICE_NAMES if i not in args])
                # From Ned Batchelder's answer on http://stackoverflow.com/a/14728477
                # class ArgumentParserError(Exception):
                #     pass
                #
                # # noinspection PyClassHasNoInit
                # class ThrowingArgumentParser(argparse.ArgumentParser):
                #     def error(self, message):
                #         raise ArgumentParserError(message)
                #
                # fake_parser = ThrowingArgumentParser()
                # for x in univ:
                #     fake_parser.add_argument(x, type=str)
                # fake_parser.add_argument('blah', nargs="*")
                # comp_list = []
                # try:
                #     fa, unk = fake_parser.parse_known_args()
                #     resdir, config = fa.resources_dir, fa.config
                #     taxalotl_config = TaxalotlConfig(filepath=config, resources_dir=resdir)
                #     if sel_cmd in res_dep_cmds:
                #         comp_list = list(taxalotl_config.resources_mgr.resources.keys())
                # except:
                #     pass

            if sel_cmd == 'config':
                #if last_word == '-':
                #    comp_list.extend(config_short + config_double)
                #elif last_word.startswith('--'):
                #    comp_list.extend(completions(last_word, config_double))
                #else:
                comp_list.extend([i for i in config_actions if i not in args])
            elif sel_cmd == 'ott':
                comp_list.extend([i for i in ott_actions if i not in args])
            if sel_cmd == 'tail':
                n_arg = False
                for a in args:
                    if a.startswith('-n'):
                        n_arg = True
                        break
                if not n_arg:
                    comp_list.append('-n')
        sys.stdout.write('{}\n'.format(' '.join(comp_list)))
    else:
        args = parser.parse_args(sys.argv[1:])
        try:
            f = args.func
        except:
            sys.exit('A command must be provided (use the -h to see the help).\n')
        from peyotl import configure_logger
        configure_logger()
        try:
            f(args)
        except Exception:
            logger(__name__).exception('terminating do to an exception:')
            sys.exit(1)

if __name__ == '__main__':
    main()
