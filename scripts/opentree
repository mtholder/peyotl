#!/usr/bin/env python
from peyotl import ConfigWrapper, logger, get_config_setting
from peyotl.otservices import (launch_services, service_status, stop_services, ALL_SERVICE_NAMES)

# from peyotl.ott import OTT
# import subprocess
import sys
import os

out = sys.stdout


def parse_config_file(fp):
    try:
        # noinspection PyCompatibility
        from ConfigParser import SafeConfigParser
    except ImportError:
        # noinspection PyCompatibility,PyUnresolvedReferences
        from configparser import ConfigParser as SafeConfigParser
    if not os.path.exists(fp):
        raise RuntimeError('The config filepath "{fp}" does not exist.'.format(fp=fp))
    config_obj = SafeConfigParser()
    config_obj.read(fp)
    return config_obj


def config_command(args):
    if args.action.lower() == 'list':
        fp = args.filepath
        if fp:
            fp = os.path.abspath(fp)
            cfg = parse_config_file(fp)
            cw = ConfigWrapper(raw_config_obj=cfg, config_filename=fp)
        else:
            cw = ConfigWrapper()
        cw.report(out)

def start_command(args):
    launch_services(args.services)

def stop_command(args):
    stop_services(args.services)

def status_command(args):
    service_status([])

def ott_list_command(args):
    ott_dir = get_config_setting(['ott', 'directory'])
    if ott_dir is None:
        sys.exit('Did not find info about a local version of OTT. Configure the '
                 '[ott] section and "directory" setting of your config file to point '
                 'to the directory that holds an unpacked version of OTT.\n')
    out.write('Using OTT in "{}"\n'.format(ott_dir))


    #
    # def ott_clear_command(args):
    #    ott = OTT()
    #    ott.remove_caches()
    # def ott_shell_command(args):
    #    ott = OTT()
    #    logger(__name__).info('launching bash in your OTT dir...')
    #    if subprocess.Popen('bash', cwd=ott.ott_dir).wait() != 0:
    #        raise RuntimeError('bash in ott dir failed.')


def main():
    import argcomplete
    import argparse

    parser = argparse.ArgumentParser(prog='opentree')
    parser.add_argument("--show-completions",
                        action="store_true",
                        default=False,
                        help="print the list of options for the next word in the command line")
    subparsers = parser.add_subparsers(help='available commands')
    ################################################################################################
    #  config commands
    config_parser = subparsers.add_parser('config',
                                          help='reports information about your peyotl configuration')
    config_parser.add_argument('-a', '--action', choices=['list'], default='list', required=False)
    config_parser.add_argument('-f', '--filepath', type=str, default=None, required=False)
    config_parser.set_defaults(func=config_command)
    ################################################################################################
    #  ott commands
    ott_parser = subparsers.add_parser('ott', help='commands that require a local version of ott')
    ott_parser.add_argument('--action', choices=['list'], default='', required=False)
    ott_subparsers = ott_parser.add_subparsers(help='ott actions')
    ott_list_parser = ott_subparsers.add_parser('list',
                                                help='reports on the local version of OTT')
    ott_list_parser.set_defaults(func=ott_list_command)
    # ott_clear_parser = ott_subparsers.add_parser('clear-cache',
    #                                             help='remove the caches used to speed up actions on OTT')
    # @TODO: Restore?
    #  ott_clear_parser.set_defaults(func=ott_clear_command)
    # ott_shell_parser = ott_subparsers.add_parser('bash',
    #                                            help='execute bash command in the top dir of your copy of OTT')
    # ott_shell_parser.set_defaults(func=ott_shell_command)
    ################################################################################################
    # Start service command
    start_parser = subparsers.add_parser('start',
                                          help='launches one of the Open Tree services locally')
    start_parser.add_argument('services', nargs='+', choices=ALL_SERVICE_NAMES, default=None)
    start_parser.set_defaults(func=start_command)
    ################################################################################################
    # Status
    status_parser = subparsers.add_parser('status',
                                         help='reports the status of open tree service/artifacts '
                                              'installation.')
    status_parser.add_argument('services', nargs='*', choices=ALL_SERVICE_NAMES, default='all')
    status_parser.set_defaults(func=status_command)
    ################################################################################################
    # Start service command
    stop_parser = subparsers.add_parser('stop',
                                         help='stops one of the Open Tree services running locally')
    stop_parser.add_argument('services', nargs='+', choices=ALL_SERVICE_NAMES, default=None)
    stop_parser.set_defaults(func=stop_command)
    ################################################################################################
    argcomplete.autocomplete(parser)
    args = parser.parse_args(sys.argv[1:])
    try:
        f = args.func
    except:
        sys.exit('A command must be provided (use the -h to see the help).\n')
    from peyotl import configure_logger
    configure_logger()
    try:
        f(args)
    except Exception:
        logger(__name__).exception('terminating do to an exception:')
        sys.exit(1)


if __name__ == '__main__':
    main()
